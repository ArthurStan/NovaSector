/datum/space_level/partition
	linkage = UNAFFECTED
	/// How many different zones is there horizontally?
	var/zones_count_x = 2
	/// How many different zones is there vertically?
	var/zones_count_y = 2
	/// What type of /datum/space_zone is this partition using?
	var/zone_type = /datum/space_zone
	/// Are the zones in this partition to be considered big enough to hold the biggest ruins?
	var/big_zones = FALSE
	/// All of the zones generated by this partition.
	var/list/datum/space_zone/zones = list()


/datum/space_level/partition/New(new_z, new_name, list/new_traits)
	. = ..()

	create_partition()


/**
 * The proc responsible to partition the z-level into multiple distinct
 * /datum/space_zone, each separated by a cordon of /turf/cordon.
 */
/datum/space_level/partition/proc/create_partition()
	var/zone_width = floor((world.maxx) / zones_count_x)
	var/zone_height = floor((world.maxy) / zones_count_y)

	var/current_border_tile_index = 1
	var/list/x_bounds = list()

	while(TRUE)
		var/list/new_entry = list(current_border_tile_index)

		current_border_tile_index += zone_width

		new_entry.Add(current_border_tile_index - 1)
		x_bounds.Add(list(new_entry))

		if(current_border_tile_index >= world.maxx)
			break

		var/list/turf/border_turfs = block(locate(current_border_tile_index, 1, z_value), locate(current_border_tile_index, world.maxy, z_value))

		for(var/turf/border_turf as anything in border_turfs)
			border_turf = new /turf/cordon(border_turf)

	current_border_tile_index = 1
	var/list/y_bounds = list()

	while(TRUE)
		var/list/new_entry = list(current_border_tile_index)

		current_border_tile_index += zone_height

		new_entry.Add(current_border_tile_index - 1)
		y_bounds.Add(list(new_entry))

		if(current_border_tile_index >= world.maxy)
			break

		var/list/turf/border_turfs = block(locate(1, current_border_tile_index, z_value), locate(world.maxx, current_border_tile_index, z_value))

		for(var/turf/border_turf as anything in border_turfs)
			border_turf = new /turf/cordon(border_turf)

	for(var/x in x_bounds)
		for(var/y in y_bounds)
			var/datum/space_zone/new_zone = new zone_type(z_value, x[1], x[2], y[1], y[2])
			new_zone.can_fit_big_ruins = big_zones
			zones += new_zone


/**
 * This is the proc that triggers populating the ruins in this partition's
 * `zones`, ensuring that it goes randomly and respects `never_spawns_with`.
 */
/datum/space_level/partition/proc/populate_ruins(list/available_ruins, list/forced_ruins, list/area_whitelist)
	for(var/datum/space_zone/zone in zones)
		var/datum/map_template/ruin/space/current_pick

		if(!length(available_ruins) && !length(forced_ruins))
			CRASH("No more ruin available to be spawned for zone ([zone.start_x], [zone.start_y], [zone.z]) and onwards.")

		if(length(forced_ruins))
			current_pick = pick(forced_ruins)
			forced_ruins -= current_pick

		if(!current_pick)
			current_pick = pick_weight(available_ruins)
			available_ruins -= current_pick

		if(current_pick.never_spawn_with)
			for(var/blacklisted_type in current_pick.never_spawn_with)
				for(var/possible_exclusion in available_ruins)
					if(istype(possible_exclusion, blacklisted_type))
						available_ruins -= possible_exclusion

		zone.spawn_ruin(current_pick, area_whitelist)


/datum/space_level/partition/four
	zones_count_x = 2
	zones_count_y = 2
	big_zones = TRUE

/datum/space_level/partition/nine
	zones_count_x = 3
	zones_count_y = 3


/datum/space_level/partition/rift
	zone_type = /datum/space_zone/rift

/datum/space_level/partition/rift/nine
	zones_count_x = 3
	zones_count_y = 3
